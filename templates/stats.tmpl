{{block "main" .}}package {{.PackageName}}

// This file is was generated automatically by Codegen {{.CodeGen.Version}}
// Do not make changes to this file as they will be lost

import (
	"encoding/json"
	"os"
	"sync"
	"time"

	"github.com/ecnepsnai/ring"
)

type cbgenStatsCounter struct {
	{{range $counter := .Stats.Counters}}
	{{$counter.Name}} uint64
	{{end}}
}

type cbgenStatsTimer struct {
	{{range $timer := .Stats.Timers}}
	{{$timer.Name}} *ring.Ring
	{{end}}
}

type cbgenStatsSavedDataType struct {
	Counters map[string]uint64
	Timers   map[string][]float64
}

type cbgenStatsObject struct {
	parent  *sync.RWMutex
	locks   map[string]*sync.Mutex
	current cbgenStatsCounter
	timers  cbgenStatsTimer
}

// Stats the global stats object
var Stats *cbgenStatsObject

// statsSetup setup the stats object
func statsSetup() {
	s := cbgenStatsObject{}
	s.parent = &sync.RWMutex{}
	s.locks = map[string]*sync.Mutex{
		{{range $counter := .Stats.Counters}}
		"{{$counter.Name}}": {},
		{{end}}
	}
	s.current = cbgenStatsCounter{}

	{{range $timer := .Stats.Timers}}
	s.timers.{{$timer.Name}} = ring.New(15)
	{{end}}

	Stats = &s
}

// Reset reset all volatile stats
func (s *cbgenStatsObject) Reset() {
	s.parent.Lock()
	defer s.parent.Unlock()

	{{range $counter := .Stats.Counters}}
	s.current.{{$counter.Name}} = 0
	{{end}}
	{{range $timer := .Stats.Timers}}
	s.timers.{{$timer.Name}} = ring.New(15)
	{{end}}
}

// Save will write all stat values to the given file name
func (s *cbgenStatsObject) Save(fileName string) error {
	s.parent.RLock()
	defer s.parent.RUnlock()

	data := cbgenStatsSavedDataType{
		Counters: s.CurrentCounters(),
		Timers: map[string][]float64{
			{{range $timer := .Stats.Timers}}
			"{{$timer.Name}}": s.All{{$timer.Name}}Samples(),
			{{end}}
		},
	}

	f, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, os.ModePerm)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := json.NewEncoder(f).Encode(&data); err != nil {
		return err
	}

	return nil
}

// Load will set all stats values to the data in file name
func (s *cbgenStatsObject) Load(fileName string) error {
	s.parent.Lock()
	defer s.parent.Unlock()

	f, err := os.OpenFile(fileName, os.O_RDONLY, os.ModePerm)
	if err != nil {
		return err
	}
	defer f.Close()

	data := cbgenStatsSavedDataType{}
	if err := json.NewDecoder(f).Decode(&data); err != nil {
		return err
	}

	{{range $counter := .Stats.Counters}}
	s.current.{{$counter.Name}} = data.Counters["{{$counter.Name}}"]
	{{end}}

	{{range $timer := .Stats.Timers}}
	s.timers.{{$timer.Name}} = ring.New(15)
	for _, sample := range data.Timers["{{$timer.Name}}"] {
		s.timers.{{$timer.Name}}.Add(sample)
	}
	{{end}}

	return nil
}

{{range $counter := .Stats.Counters}}
// Increment{{$counter.Name}} increment {{$counter.Description}}
func (s *cbgenStatsObject) Increment{{$counter.Name}}() {
	s.parent.RLock()
	defer s.parent.RUnlock()
	lock := s.locks["{{$counter.Name}}"]
	lock.Lock()
	defer lock.Unlock()
	s.current.{{$counter.Name}}++
}

// Decrement{{$counter.Name}} decrement {{$counter.Description}}
func (s *cbgenStatsObject) Decrement{{$counter.Name}}() {
	s.parent.RLock()
	defer s.parent.RUnlock()
	lock := s.locks["{{$counter.Name}}"]
	lock.Lock()
	defer lock.Unlock()
	s.current.{{$counter.Name}}--
}

// Set{{$counter.Name}} set {{$counter.Description}}
func (s *cbgenStatsObject) Set{{$counter.Name}}(newVal uint64) {
	s.parent.RLock()
	defer s.parent.RUnlock()
	lock := s.locks["{{$counter.Name}}"]
	lock.Lock()
	defer lock.Unlock()
	s.current.{{$counter.Name}} = newVal
}
{{end}}

// CurrentCounters get a map of current counters
func (s *cbgenStatsObject) CurrentCounters() map[string]uint64 {
	s.parent.RLock()
	defer s.parent.RUnlock()
	m := map[string]uint64{}
	for _, l := range s.locks {
		l.Lock()
	}
	{{range $counter := .Stats.Counters}}
	m["{{$counter.Name}}"] = s.current.{{$counter.Name}}
	{{end}}
	for _, l := range s.locks {
		l.Unlock()
	}
	return m
}

{{range $timer := .Stats.Timers}}
// Add{{$timer.Name}} add a sample of {{$timer.Description}}
func (s *cbgenStatsObject) Add{{$timer.Name}}(value time.Duration) {
	s.parent.RLock()
	defer s.parent.RUnlock()
	// Don't need to lock ourselves as ring is threadsafe
	s.timers.{{$timer.Name}}.Add(value)
}

// Average{{$timer.Name}} get the average time for the {{$timer.Name}} timer
func (s *cbgenStatsObject) Average{{$timer.Name}}() float64 {
	s.parent.RLock()
	defer s.parent.RUnlock()

	var average float64

	{{$timer.Name}}s := s.timers.{{$timer.Name}}.All()
	if len({{$timer.Name}}s) > 0 {
		var {{$timer.Name}}Sum float64
		for _, obj := range {{$timer.Name}}s {
			{{$timer.Name}} := obj.(time.Duration)
			{{$timer.Name}}Sum += float64({{$timer.Name}}.Milliseconds())
		}
		average = {{$timer.Name}}Sum / float64(len({{$timer.Name}}s))
	}

	return average
}

// All{{$timer.Name}}Samples get all samples for the {{$timer.Name}} timer
func (s *cbgenStatsObject) All{{$timer.Name}}Samples() []float64 {
	s.parent.RLock()
	defer s.parent.RUnlock()

	all := s.timers.{{$timer.Name}}.All()
	if len(all) == 0 {
		return []float64{}
	}

	samples := make([]float64, len(all))
	for i, s := range all {
		samples[i] = float64(s.(time.Duration).Milliseconds())
	}

	return samples
}
{{end}}

// GetTimerAverages get the average times for all timers
func (s *cbgenStatsObject) GetTimerAverages() map[string]float64 {
	s.parent.RLock()
	defer s.parent.RUnlock()

	averages := map[string]float64{}

	{{range $timer := .Stats.Timers}}
	{{$timer.Name}}s := s.timers.{{$timer.Name}}.All()
	if len({{$timer.Name}}s) > 0 {
		var {{$timer.Name}}Sum float64
		for _, obj := range {{$timer.Name}}s {
			{{$timer.Name}} := obj.(time.Duration)
			{{$timer.Name}}Sum += float64({{$timer.Name}}.Milliseconds())
		}
		{{$timer.Name}}Avg := {{$timer.Name}}Sum / float64(len({{$timer.Name}}s))
		averages["{{$timer.Name}}"] = {{$timer.Name}}Avg
	}
	{{end}}

	return averages
}
{{end}}
